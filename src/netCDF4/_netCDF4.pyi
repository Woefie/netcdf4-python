from typing import TypeAlias, Literal, Optional, Any, Tuple
import numpy.typing as npt
import os
import datetime
import cftime  # type: ignore

Datatype: TypeAlias = Literal['S1', 'c', 'i1', 'b', 'B', 'u1', 'i2',
                              'h', 's', 'u2', 'i4', 'i', 'l', 'u4',
                              'i8', 'u8', 'f4', 'f', 'f8', 'd']
Compression: TypeAlias = Literal['zlib', 'szip', 'zstd', 'blosc_lz',
                                 'blosc_lz4', 'blosc_lz4hc', 'blosc_zlib', 'blosc_zstd']
AccessMode: TypeAlias = Literal['r', 'w',
                                'r+', 'a', 'x', 'rs', 'ws', 'r+s', 'as']
Format: TypeAlias = Literal['NETCDF4', 'NETCDF4_CLASSIC', 'NETCDF3_CLASSIC',
                            'NETCDF3_64BIT_OFFSET', 'NETCDF3_64BIT_DATA']
DiskFormat: TypeAlias = Literal['NETCDF3', 'HDF5', 'HDF4',
                                'PNETCDF', 'DAP2', 'DAP4', 'UNDEFINED']
default_fillvals: dict[str, int | float]

__version__: str
__netcdf4libversion__: str
__hdf5libversion__: str
__has_rename_grp__: bool
__has_nc_inq_path__: bool
__has_nc_inq_format_extended__: bool
__has_nc_open_mem__: bool
__has_nc_create_mem__: bool
__has_cdf5_format__: bool
__has_parallel4_support__: bool
__has_pnetcdf_support__: bool
__has_parallel_support__: bool
__has_quantization_support__: bool
__has_zstandard_support__: bool
__has_bzip2_support__: bool
__has_blosc_support__: bool
__has_szip_support__: bool
__has_set_alignment__: bool
__has_ncfilter__: bool
is_native_little: bool
is_native_big: bool
default_encoding: str
unicode_error: str


class NetCDF4MissingFeatureException(Exception):
    ...

    def __init__(
        self,
        feature: str,
        version: str
    ): ...


class Dataset:
    ...
    @property
    def groups(self) -> dict[str, Group]: ...
    @property
    def dimensions(self) -> dict[str, Dimension]: ...
    @property
    def variables(self) -> dict[str, Variable]: ...
    @property
    def cmptypes(self) -> dict[str, CompoundType]: ...
    @property
    def vltypes(self) -> dict[str, VLType]: ...
    @property
    def enumtypes(self) -> dict[str, EnumType]: ...
    @property
    def data_model(self) -> Format: ...
    @property
    def file_format(self) -> Format: ...
    @property
    def disk_format(self) -> DiskFormat: ...
    @property
    def parent(self) -> Dataset | None: ...
    @property
    def path(self) -> os.PathLike | str: ...
    @property
    def keepweakref(self) -> bool: ...
    @property
    def _ncstring_attrs__(self) -> bool: ...
    @property
    def __orthogonal_indexing__(self) -> bool: ...

    def __init__(
        self,
        filename: str | os.PathLike,
        mode: AccessMode = 'r',
        clobber: bool = True,
        format: Format = 'NETCDF4',
        diskless: bool = False,
        persist: bool = False,
        keepweakref: bool = False,
        memory: Optional[Literal['r', 'w']] = None,
        encoding: Optional[str] = None,
        parallel: bool = False,
        comm=None,
        info=None,
        **kwargs
    ): ...

    def filepath(self, encoding: Optional[str] = None) -> str: ...
    def isopen(self) -> bool: ...
    def close(self) -> bool: ...
    def sync(self) -> None: ...
    def set_fill_on(self) -> None: ...
    def set_fill_off(self) -> None: ...

    def createDimension(
        self,
        dimname: str,
        size: Optional[int] = None
    ) -> Dimension: ...

    def renameDimension(
        self,
        oldname: str,
        newname: str
    ) -> None: ...

    def createCompoundType(
        self,
        datatype: npt.DTypeLike,
        datatype_name: str
    ) -> CompoundType: ...

    def createVLType(
        self,
        datatype: npt.DTypeLike,
        datatype_name: str
    ) -> VLType: ...

    def createEnumType(
        self,
        datatype: npt.DTypeLike,
        datatype_name: str,
        enum_dict: dict[str, int]
    ) -> EnumType: ...

    def createVariable(
        self,
        varname: str,
        datatype: Datatype | npt.DTypeLike | str | CompoundType | VLType,
        dimensions: Tuple[str] | Tuple[()] | str | Dimension = (),
        compression: Optional[Compression] = None,
        zlib: bool = False,
        complevel: Optional[Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]] = 4,
        shuffle: bool = True,
        szip_coding: Literal['nn', 'ec'] = 'nn',
        szip_pixels_per_block: Literal[4, 8, 16, 32] = 8,
        blosc_shuffle: Literal[0, 1, 2] = 1,
        fletcher32: bool = False,
        contiguous: bool = False,
        chunksizes: Optional[int] = None,
        endian: Literal['native', 'little', 'big'] = 'native',
        least_significant_digit: Optional[int] = None,
        significant_digits: Optional[int] = None,
        quantize_mode: Literal['BitGroom', 'BitRound',
                               'GranularBitRound'] = 'BitGroom',
        fill_value: Optional[bool] = None,
        chunk_cache: Optional[int] = None
    ) -> Variable: ...

    def renameVariable(self, oldname: str, newname: str) -> None: ...
    def createGroup(self, groupname: str) -> Group: ...
    def ncattrs(self) -> list[str]: ...
    def setncattr_string(self, name: str, value) -> None: ...
    def setncattr(self, name: str, value) -> None: ...
    def setncatts(self, attdict) -> None: ...
    def getncattr(self, name: str, encoding='utf-8') -> Dataset | Group: ...
    def delncattr(self, name: str) -> None: ...
    def renameAttribute(self, oldname: str, newname: str) -> None: ...
    def renameGroup(self, oldname: str, newname: str) -> None: ...
    def set_auto_chartostring(self, value) -> None: ...
    def set_auto_maskandscale(self, value) -> None: ...
    def set_auto_mask(self, value) -> None: ...
    def set_auto_scale(self, value) -> None: ...
    def set_always_mask(self, value) -> None: ...
    def set_ncstring_attrs(self, value) -> None: ...
    def get_variables_by_attributes(self, **kwargs) -> list[Variable]: ...

    @property
    def name(self) -> str: ...

    @staticmethod
    def fromcdl(
        cdlfilename: str,
        ncfilename: Optional[str] = None,
        mode: AccessMode = 'a',
        format: Format = 'NETCDF4'
    ) -> Dataset: ...

    def tocdl(
        self,
        coordvars: bool = False,
        data: bool = False,
        outfile: Optional[str] = None
    ) -> None | bool: ...

    def has_blosc_filter(self) -> bool: ...
    def has_zstd_filter(self) -> bool: ...
    def has_bzip2_filter(self) -> bool: ...
    def has_szip_filter(self) -> bool: ...

    def __setattr__(self, name: str, value): ...
    def __getattr__(self, name: str): ...
    def __delattr__(self, name: str): ...
    def __enter__(self) -> Dataset: ...
    def __exit__(self, atype, value, traceback) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...


class Group(Dataset):
    ...

    def __init__(
        self,
        parent: Group | Dataset,
        name: str,
        **kwargs
    ): ...
    def close(self) -> bool: ...


class Dimension:
    ...

    def __init__(
        self,
        grp: Group,
        name: str,
        size: Optional[int] = None,
        **kwargs
    ): ...
    @property
    def name(self) -> str: ...
    @property
    def size(self) -> int: ...
    def group(self) -> Group: ...
    def isunlimited(self) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...


class Variable:
    ...

    @property
    def dimensions(self) -> Tuple[str]: ...
    @property
    def dtype(self) -> npt.DTypeLike: ...
    @property
    def ndim(self) -> int: ...
    @property
    def shape(self) -> Tuple[int]: ...
    @property
    def scale(self) -> bool: ...
    @property
    def mask(self) -> bool: ...
    @property
    def chartostring(self) -> bool: ...
    @property
    def always_mask(self) -> bool: ...

    def __init__(
        self,
        grp: Group,
        name: str,
        datatype: Datatype | npt.DTypeLike | str | CompoundType | VLType,
        dimensions: Tuple[str] | Tuple[()] | str | Dimension = (),
        compression: Optional[Compression] = None,
        zlib: bool = False,
        complevel: Optional[Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]] = 4,
        shuffle: bool = True,
        szip_coding: Literal['nn', 'ec'] = 'nn',
        szip_pixels_per_block: Literal[4, 8, 16, 32] = 8,
        blosc_shuffle: Literal[0, 1, 2] = 1,
        fletcher32: bool = False,
        contiguous: bool = False,
        chunksizes: Optional[int] = None,
        endian: Literal['native', 'little', 'big'] = 'native',
        least_significant_digit: Optional[int] = None,
        significant_digits: Optional[int] = None,
        quantize_mode: Literal['BitGroom', 'BitRound',
                               'GranularBitRound'] = 'BitGroom',
        fill_value: Optional[bool] = None,
        chunk_cache: Optional[int] = None,
        **kwargs
    ): ...

    def group(self) -> Group: ...
    def ncattrs(self) -> list[str]: ...
    def setncattr(self, name: str, value) -> None: ...
    def setncattr_string(self, name: str, value) -> None: ...
    def setncatts(self, attdict) -> None: ...
    def getncattr(self, name: str, encoding='utf-8'): ...
    def delncattr(self, name: str) -> None: ...
    def filters(self) -> dict: ...
    def quantization(self) -> int: ...
    def endian(self) -> str: ...
    def chunking(self) -> str | list[int]: ...
    def get_var_chunk_cache(self) -> tuple[int, int, float]: ...

    def set_var_chunk_cache(
        self,
        size: Optional[int] = None,
        nelems: Optional[int] = None,
        preemption: Optional[float] = None
    ) -> None: ...

    def renameAttribute(self, oldname: str, newname: str) -> None: ...
    def assignValue(self, val) -> None: ...
    def getValue(self) -> Any: ...
    def set_auto_chartostring(self, chartostring) -> None: ...
    def use_nc_get_vars(self, use_nc_get_vars) -> None: ...
    def set_auto_maskandscale(self, maskandscale) -> None: ...
    def set_auto_scale(self, scale) -> None: ...
    def set_auto_mask(self, mask) -> None: ...
    def set_always_mask(self, always_mask) -> None: ...
    def set_ncstring_attrs(self, ncstring_attrs) -> None: ...
    def set_collective(self, value) -> None: ...
    def get_dims(self) -> tuple[Dimension]: ...

    @property
    def name(self) -> str: ...
    @property
    def datatype(self) -> CompoundType | VLType | EnumType: ...
    @property
    def size(self) -> int: ...
    @property
    def __orthogonal_indexing__(self) -> bool: ...

    def __setitem__(self, elem, data): ...
    def __len__(self) -> int: ...
    def __array__(self) -> npt.ArrayLike: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __delattr__(self, name: str): ...
    def __setattr__(self, name: str, value): ...
    def __getattr__(self, name: str): ...
    def __getitem__(self, elem): ...


class CompoundType:
    ...
    @property
    def dtype(self) -> npt.DTypeLike: ...
    @property
    def name(self) -> str: ...
    @property
    def dtype_view(self) -> npt.DTypeLike: ...

    def __init__(self, grp, datatype, dtype_name, **kwargs): ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __reduce__(self): ...


class VLType:
    ...
    @property
    def dtype(self) -> npt.DTypeLike: ...
    @property
    def name(self) -> str: ...

    def __init__(
        self,
        grp: Group,
        datatype: npt.DTypeLike,
        dtype_name: str,
        **kwargs
    ): ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __reduce__(self): ...


class EnumType:
    ...
    @property
    def dtype(self) -> npt.DTypeLike: ...
    @property
    def name(self) -> str: ...
    @property
    def enum_dict(self) -> dict[str, int]: ...

    def __init__(
        self,
        grp: Group,
        datatype: npt.DTypeLike,
        dtype_name: str,
        enum_dict: dict[str, int],
        **kwargs
    ): ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __reduce__(self): ...


class MFDataset(Dataset):
    ...

    def __init__(
        self,
        files: str | os.PathLike,
        check: bool = False,
        aggdim: Optional[str] = None,
        exclude: list[str] = [],
        master_file: Optional[str | os.PathLike] = None
    ): ...

    def __setattr__(self, name: str, value: Any): ...
    def __getattribute__(self, name: str): ...
    def ncattrs(self): ...
    def close(self): ...
    def isopen(self) -> bool: ...
    def __repr__(self) -> str: ...
    def __reduce__(self): ...


class _Variable:
    ...
    def __init__(self, dset, varname, var, recdimname): ...
    def __getattr__(self, name): ...
    def __repr__(self): ...
    def __len__(self): ...
    def __getitem__(self, elem): ...

    def typecode(self): ...
    def ncattrs(self): ...
    def _shape(self): ...
    def set_auto_chartostring(self, val): ...
    def set_auto_maskandscale(self, val): ...
    def set_auto_mask(self, val): ...
    def set_auto_scale(self, val): ...
    def set_always_mask(self, val): ...


class MFTime(_Variable):
    ...

    def __init__(
        self,
        time: Variable,
        units=None,
        calendar: Optional[Literal['standard', 'gregorian']] = None
    ): ...
    def __getitem__(self, elem): ...


def stringtoarr(string, NUMCHARS: int, dtype: str = 'S'): ...
def stringtochar(a, encoding='utf-8'): ...
def chartostring(b, encoding='utf-8'): ...
def getlibversion() -> str: ...
def set_alignment(threshold: int, alignment: int): ...
def get_alignment() -> tuple[int, int]: ...


def set_chunk_cache(size: Optional[int] = None,
                    nelems: Optional[int] = None,
                    preemption: Optional[float] = None): ...


def get_chunk_cache() -> tuple[int, int, float]: ...


def date2index(
    dates: datetime.datetime | cftime.datetime,
    nctime: MFTime,
    calendar: Optional[Literal['standard', 'gregorian', 'proleptic_gregorian' 'noleap',
                               '365_day', '360_day', 'julian', 'all_leap', '366_day']] = None,
    select: Literal['exact', 'before', 'after', 'nearest'] = 'exact',
    has_year_zero: Optional[bool] = None): ...


def date2num(
    dates: datetime.datetime | cftime.datetime,
    units: str,
    calendar: Optional[Literal['standard', 'gregorian', 'proleptic_gregorian' 'noleap',
                               '365_day', '360_day', 'julian', 'all_leap', '366_day']] = None,
    has_year_zero: Optional[bool] = None,
    longdouble: bool = False
): ...


def num2date(
    times: Any,
    units: str,
    calendar: Literal['standard', 'gregorian', 'proleptic_gregorian' 'noleap',
                      '365_day', '360_day', 'julian', 'all_leap', '366_day'] = 'standard',
    only_use_cftime_datetimes: bool = True,
    only_use_python_datetimes: bool = False,
    has_year_zero: Optional[bool] = None
): ...
